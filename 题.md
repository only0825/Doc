# 登陆



## JWT是什么

JWT是json web token缩写。它将用户信息加密到token里，服务器不保存任何用户信息。服务器通过使用保存的密钥验证token的正确性，只要正确即通过验证。基于token的身份验证可以替代传统的cookie+session身份验证方法。

## JWT使用流程

初次登陆：用户初次登陆，输入用户名密码

密码验证：服务器从数据库取出用户名和密码进行验证

生成JWT：服务器端验证通过，根据数据库返回的信息，以及预设规则，生成JWT

返还JWT：服务器的HTTP RESPONSE中将JWT返还

带JWT的请求：以后客户端发起请求，HTTP REQUEST

HEADER 中的 Authorization 字段要有值，为JWT

服务器验证JWT

## 基于session的登录认证

在传统的用户登录认证中，因为http是无状态的，所以都是采用session方式。用户登录成功，服务端会保证一个session，当然会给客户端一个sessionId，客户端会把sessionId保存在cookie中，每次请求都会携带这个sessionId。

cookie+session这种模式通常是保存在内存中，而且服务从单服务到多服务会面临的session共享问题，随着用户量的增多，开销就会越大。而JWT不是这样的，只需要服务端生成token，客户端保存这个token，每次请求携带这个token，服务端认证解析就可。




# Redis



## Redis 到底是单线程还是多线程

* Redis 6.0 之前网络I/O 和 键值对 读写是由一个线程完成

* Redis 6.0 之后网络请求过程采用多线程，键值对读写命令依然是单线程处理，所以Redis 仍是并发安全的。
* 只有网络请求、数据操作模块是单线程，而其他的持久化、集群数据同步等，其实是由额外的线程执行的。



## Redis 单线程为什么还能这么快

1、命令执行基于内存操作，一条命了再内存里操作的时间是几十纳秒

2、命令执行是单线程操作，没有线程切换开销

3、基于 IO 多路复用机制提升 Redis 的I/O利用率

4、搞笑的数据存储结构：全局 hash 表以及多种高效数据结构，比如：跳表，压缩列表，链表等等



## Redis 主从、哨兵、集群架构优缺点比较

### 主从

* master 节点挂掉后，需要手动(写脚本)指定新的master，可用性不高，基本不用

### 哨兵

* 如果master节点异常，则会做主从切换，将某一台slave作为master。
* 哨兵配置略微复杂，并且性能和高可用性等方面表现一般，特别是在主从切换的瞬间存在访问瞬断的情况。
* 单个主节点内存不宜过大（不超过10G），否则否则会导致持久化文件过大，影响数据恢复或主从同步的效率

### 集群

* 由多个主从节点群组撑的分布式服务器群，具有复制、高可用和分片特性。
* 不需要sentine哨兵，也能完成节点移除和故障转移的功能。
* 需要将每个节点设置成集群模式，没有中心节点，可水平扩展。
* 官方文档说可线性扩展到上万个节点（推荐不超过1000个节点）。
* 性能和高可用性高于哨兵，且配置简单。



## 缓存雪崩、缓存穿透、缓存击穿



### 缓存雪崩

缓存雪崩是指缓存同一时间大面积失效，所以，后面的请求都会落到数据库熵，造成数据库短时间内成熟大量请求而崩掉。

**解决方案：**

* 缓存数据的过期时间`设置随机`，防止同一时间大量数据过期现象发生。
* 给每一个缓存数据增加相应的`缓存标记`，记录缓存是否失效，如果缓存标记失败，则更新数据缓存。
* `缓存预热`（写个接口 把热点数据放到存储中去，再启动redis）（故障导致数据都没了重启 或 第一次启动还没有数据 的**场景**）
* `互斥锁`（查一个缓存发现失效了，要去查库，查库的时候把缓存这个键锁起来，查完库后放入缓存再释放锁，可以防止大量请求对同一个键进行操作）



### 缓存穿透

缓存穿透是指缓存和数据库中都没有数据，导致所有的请求都落到数据库上，造成数据库短时间承受大量请求而崩掉。（一般是在攻击 或 商城等高并发场景才会出现缓存穿透）

**解决方案**：

* 接口层增加校验，如用户鉴权校验，id做基础校验，id<=0的直接拦截。
* 从缓存取不到且数据库也没有，这时也可将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击
* 采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力



### 缓存击穿

缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间过大，造成过大压力。和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据查不到从而查数据库

**解决方案**

* 设置热点数据用不过期
* 加互斥锁



# 消息队列



# Mysql

https://github.com/caokegege/Interview/blob/master/db/%E6%9C%80%E5%85%A8MySQL%E9%9D%A2%E8%AF%9560%E9%A2%98%E5%92%8C%E7%AD%94%E6%A1%88.md



