gray817gz@gmail.com 1Q2w3e4r@

github: gray817gz@gmail.com 1Q2w3e4r@33

AppleID: gray817gz@gmail.com GxpT6tZnCgEjPP9



公司邮箱  账号: TL007788 密码: 1Q2w3e4r@

**白马开户信息**

| 部门 | 公司英文名 | 手机号码    | 白马会户名 | 国籍     | 月日年    |
| ---- | ---------- | ----------- | ---------- | -------- | --------- |
| GZ1  | Gray       | 09266777773 | baray      | 马来西亚 | 6/21/1992 |



## 20220902

准备做

\1. 聊天室 删除单条消息

\2. 弹幕实现

\5. 赛事推荐 拿的时间也  优先级：有无主播、 开播时间

\6. 机器人 进聊天室 （为了炒直播间）



敏感字未屏蔽 （感觉可以用es做，但暂时不做）



完成：

##### 这里是1级联赛

![image-20220902141440343](/Users/wh37/Library/Application Support/typora-user-images/image-20220902141440343.png)

##### 联赛查询结果改为1、2级（之前为1级）

![image-20220902132614548](/Users/wh37/Library/Application Support/typora-user-images/image-20220902132614548.png)

##### 全部直播和热门直播 看看排序是按什么的

热门直播和全部直播调用的一个接偶/api/live/hotRoom

排序规则：sort从大到小、热度从大到小

sort的优先级高于热度

查询条件：当后台直播管理的推荐开启时 





##### 赛程和未来赛程接口调整 

这两个接口一样 

/api/scheduleMatch/lists

/api/scheduleMatch/matchLists



##### 赛程接口查询时间区间：改为早上的08:00:00点到第二日早上的07:59:59



## 20220903



#### TODO

\1. 聊天室 删除单条消息

\2. 弹幕实现

\5. 赛事推荐 拿的时间也  优先级：有无主播、 开播时间

\6. 机器人 进聊天室 （为了炒直播间）



敏感字未屏蔽 （感觉可以用es做，但暂时不做）





#### 完成

Bug修复：

\1. 预约赛事后取消预约 再次预约该比赛 但名称不会改变的问题

\2. 重新预约相同赛事update_time没有更新问题

\3. 开始预约的直播后显示数据不对，原因：字段和表不符合



直播时长问题：

![image-20220903204350383](/Users/wh37/Library/Application Support/typora-user-images/image-20220903204350383.png)





## 20220905

#### TODO

\1. 聊天室 删除单条消息

\2. 弹幕实现



\6. 机器人 进聊天室 （为了炒直播间）



敏感字未屏蔽 （感觉可以用es做，但暂时不做）



1. 设计篮球联赛赛程表
   * 参考足球赛程表
   * 从飞鲸篮球API的3.赛程赛果 接口拿字段
2. 设计篮球联赛表
   * 看看能不能和足球联赛表兼容，不能就重新设计一个
   * 飞鲸 9.联赛/杯赛资料 这个接口
3. 球队表
   * 飞鲸 12.球队资料

![image-20220905212715621](/Users/wh37/Library/Application Support/typora-user-images/image-20220905212715621.png)

完成

* 赛事推荐 拿的时间也  优先级：有无主播、 开播时间

* **赛事现在是展示8-8时  改回原来的逻辑 展示当天00:00 - 23:59**



根据第三方API 设计篮球联赛赛程表

https://www.feijing88.com/doc?id=37-451&token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0b2tlbiI6ImVlYzkyTGdsbG1tc3lCUFVZR29WbDFtNVRHSXpvb29YTWpPQ3k1bUhQTW91REhEWE53QXM4Qm13WUNzSC9Wd0ciLCJpYXQiOjE2NjE2Nzc2MDZ9.qHaaLJe_YherF-8PW0dGfq-RQ6R4JsOnIdWsUov65Uc





## 20220906

#### TODO

聊天室 删除单条消息

弹幕实现

机器人 进聊天室 （为了炒直播间）

敏感字未屏蔽 （感觉可以用es做，但暂时不做）



完成：

1. **设计篮球联赛赛程表**
   * 参考足球赛程表
   * 从飞鲸篮球API的3.赛程赛果 接口拿字段
2. **设计篮球联赛表**
   * 看看能不能和足球联赛表兼容，不能就重新设计一个
   * 飞鲸 9.联赛/杯赛资料 这个接口
3. **篮球球队表**
   * 飞鲸 12.球队资料

## 20220907

#### TODO

* 文字直播接口

  * http://api.wuhaicj.com/apidoc/#/api?key=api_POST_/api/scheduleMatch/lineup&appKey=api

  * 参考出场阵容接口写一个文字直播接口
  * 接口拼接格式：football/textLive.aspx?language=cn&matchId=2277843

## 20220909

https://www.wutiyu.com/。爬取最新文章的内容

使用 go-query 完成





## 20220910

* /api/scheduleMatch/lineup  出场阵容接口 调整	

* 增加数据：**进球数，助攻数，红牌，黄牌，上场时间和球员头像**
* **进球数**，**助攻数，红牌，黄牌，上场时间**这几个可以从飞鲸 `11.某场比赛`的球员详细技术统计这个接口拿到
* 然后**球员头像**可以从飞鲸这个接口`20.球员资料` 拿到



爬资讯程序有几个问题

* 如果只放测试环境，不放正式环境

  * 图片怎么同步到正式环境，传到图片服务器？或直接用测试地址访问图片？
  * 资讯数据是否需要每日更新，如需要每天都要将数据导入到正式环境的表。

  

## 20220912

### OBS串流秘钥有空格

直播管理：OBS串流秘钥：dhmveB 2000091?txSecret=131c7ee6ee212fae3a01289271a9d256&txTime=632019C1

`$streamName = $this->randomKeys(6) . trim($room_id) = "dhmveB 2000091"`

排查应该是$room_id有空格，用trim去除空格ss



### 出场阵容接口调整

新增两个返回字段， 主队名称 和 客队名称 ，与homeCoachCn同级



### 聊天室断开连接时 删除游客redis数据 Gray817 Yesterday 19:32







## 20220914

需要出三个接口：

1、 获取是否开启审核模式的接口

2、 获取资讯列表接口,支持分页，返回字段包括：资讯id、标题、一张图片地址（没有可以不返回，多张取第一张）

3、 根据id获取资讯详情接口，返回字段包括：资讯id、文章标题、文章内容、图片路径、作者、文章日期

审核模式的话，返回两个字段 ，iOS 和 安卓 各用一个。数字类型， 0 关闭，1开启



4、后台可能还需要一个设置审核模式的接口



## 20220916

完成：资讯列表接口





## 20220919



```
1、 api/scheduleMatch/preList 接口
    需要新增用户是否关注该主播字段返回，未登录默认返回未关注
    scheduled_anchor 返回的是null
    待确认： 是否只有直播中的主播才返回 room_id
2、 api/scheduleMatch/lists 赛程接口
    leagueId 需要支持传多个id查询
```

### 完成：

#### 主播预约赛程接口 /api/scheduleMatch/preList

新增字段

1. 新增用户是否关注该主播字段返回
2. 主播是否在直播 

#### 赛程接口 的参数leagueId 需要支持传多个id查询

api/scheduleMatch/lists 







## 20220930

聊天室后端代码优化调整: 

1.传 member_id 时会员未登陆增加 msg 提示，提示内容'用户未登陆'

2.调整游客和会员redis存储结构，方便统计房间在线人数 

3.会员redis过期时间调整，关闭客户端时就删除该用户redis数据



后台直播间列表接口

* 查询直播间人数改查redis







## 赛程 list 优化思考



用计划任务jiang





## 直播间验证用户登陆和多端同时登陆

### 为何会提出这个需求？

因为一个Bug:

* 一个会员打开一个浏览器页面并进入到聊天室不退出，另外开一个页面退出，这时会员依然可以发送小心，并且刷新在聊天室内依然是登陆状态





## 后台直播间列表接口优化 20220930

### 为什么要优化？

1. 接口响应时间：3s+，
2. 查询直播间在线人数是请求第三方，如果第三方网络不好等待时间更长
3. 如果第三方无法返回，那么我们的接口也会超时

### 优化思路

* 用别的方法来统计直播间在线人数；
* 要看看聊天室有没有统计在线人数。

### 分析旧代码

聊天室

* 会员Redis存储SET, key：memberInfo.会员id   value: 会员数据，过期时间3600s

* 游客Redis存储SET, key：visitorMember.$client_id   value: 会员名称

  onClose 断开客户端连接时，删除游客的redis

结论：

* 会员redis设置的过期时间，而不是退出时删除redis，这样统计时就不准确

### 代码优化

聊天室：

$member_id 存入SESSION，onClose中从SESSION拿到member_id，然后删除

```php
// hash结构
Cache::store('redis')->hSet('liveRoomMember', $member_id, json_encode($member));
Cache::store('redis')->hSet('liveRoomVisitor', $client_id, json_encode($message));

```

直播间列表接口：

将redis会员和游客都查出来，再赋值给不同的

### 成果

将一个慢查询，



## 上线

```sql
20221018 上线：
ALTER TABLE hn_live_room ADD COLUMN chatroom_status TINYINT(1) DEFAULT 1 COMMENT '直播间聊天室状态 1开启 2关闭 (只对绿包使用)' AFTER status;

20221104 上线 用户来源功能
ALTER TABLE db_hainiu.hn_member 
ADD COLUMN channel varchar(50) NULL COMMENT '注册渠道' AFTER update_by;
ALTER TABLE hn_live_room ADD COLUMN video_url VARCHAR(255) DEFAULT '' COMMENT '视频地址';


```



#### 上线要加的配置

config/wechat.php

common/下的东西

```sql
ALTER TABLE hn_live_history ADD COLUMN video_url VARCHAR(255) DEFAULT '' COMMENT '视频地址';

ALTER TABLE hn_preordain ADD COLUMN video_url VARCHAR(255) DEFAULT '' COMMENT '视频地址';
```



https://t.me/jobfinder1

https://t.me/zhaopinqiuzhi

#### 

篮球表调整

```sql
ALTER TABLE hn_basketball_schedule CHANGE leagueType quarter TINYINT(1) DEFAULT NULL COMMENT '比赛小节数 2：上下半场  4：4小节';

ALTER TABLE hn_basketball_schedule ADD COLUMN leagueType TINYINT(1) DEFAULT 2 COMMENT '联赛类型 1足球 2篮球 3电竞 4其他';

ALTER TABLE hn_basketball_leagues CHANGE leagueType quarter TINYINT(1) DEFAULT NULL COMMENT '比赛小节数 2：上下半场  4：4小节';

ALTER TABLE hn_basketball_leagues ADD COLUMN leagueType TINYINT(1) DEFAULT 2 COMMENT '联赛类型 1足球 2篮球 3电竞 4其他';

ALTER TABLE hn_basketball_schedule CHANGE matchState state TINYINT(4) DEFAULT NULL COMMENT "比赛状态 0:未开赛 1:一节 2:二节 3:三节 4:四节 5:1'OT 6:2'OT 7:3'OT 50:中场 -1:完场 -2:待定 -3:中断 -4:取消 -5:推迟"

ALTER TABLE hn_basketball_leagues ADD COLUMN hierarchy TINYINT(3) DEFAULT 3 COMMENT '赛事级别 1、2、3级别赛事 4级为不展示的赛事';

ALTER TABLE hn_basketball_schedule ADD COLUMN   INT(11) DEFAULT 0 COMMENT '关注人数';


字段调整总结：

hn_basketball_schedule 表 
1. leagueType 改为 quarter
2. 新增了leagueType
3. matchState 改为 state
4. 新增 follow
5. 主队客队相关字段去掉team
6. leagueChs、leagueCht 改为 leagueChsShort、leagueChtShort

hn_basketball_leagues 表
1. leagueType 改为 quarter
2. 新增leagueType
3. 新增 hierarchy
4. logo 改为 leagueLogo


```





## 篮球



```
-- 篮球的设计稿出来了，
1.篮球联赛排名    1   （首页篮球积分榜）  完成！！
联赛  NBA  CBA 
NBA ->东部 -  西部
排名  球队  胜 负 胜率
CBA ->
排名  球队  胜  负  胜率

2.篮球联赛（赛事推荐）1.5    完成！！
进行中  
未开始 
已结束    和足球数据一样 需要加上主播排序逻辑  
有主播 优先级最高 
其次 按照和足球一致逻辑排序展示

3.篮球比赛赛程    2   完成！！
预约  取消预约   前往直播间逻辑
时间查询   （按照足球展示以及查询逻辑，比分展示需要调整）
默认图标需要调整

4.篮球比赛赛果    0.5   
pc查看已结束   其他 直接查看赛果

5.篮球赛事-主播预约     0.5
获取篮球赛事列表  进行主播预约赛事

6.篮球赛事-用户预约     0.5
预约看球赛事 展示我的预约列表

7.篮球赛事- 开播       1
获取篮球赛事列表  进行主播开播赛事
开播后  返现开播信息较难处理 之前只需要处理一种赛事 

涉及到其他界面的展示  
例如篮球  直播间内 赛事信息也应当为篮球展示
篮球比分数据  应当实时刷新（可考虑在优化项内）
优化项考虑1天时间 （包括自测以及发现问题）1
测试预留两天时间  2
```




## TODO



### 20221026-now

#### 播放视频

```
直播间的/api/live/live接口会新增个video_url 字段

处理逻辑： 如果有视频(video_url)就播放视频，并且不能切换清晰度；  如果video_url为空，播放拉流，可切换清晰度
```

![telegram-cloud-photo-size-5-6249118742588011259-y](/Users/wh37/Library/Group Containers/6N38VWS5BX.ru.keepcoder.Telegram/stable/account-603578246170668601/postbox/media/telegram-cloud-photo-size-5-6249118742588011259-y.jpg)

```php
   /**
     * @Apidoc\Title("视频开播")
     * @Apidoc\Desc("视频开播")
     * @Apidoc\Method("POST")
     * @Apidoc\Author("Gray")
     * @Apidoc\Tag("直播管理接口")
     * @Apidoc\Param("member_id", type="int",require=false,desc="主播id")
     * @Apidoc\Param("match_id", type="int",require=false,desc="比赛id")
     * @Apidoc\Param("type", type="int",require=true,desc="直播分类 1足球 2篮球 3电竞 4其他")
     * @Apidoc\Param("room_title", type="int",require=false,desc="直播间标题")
     * @Apidoc\Param("live_cover", type="int",require=false,desc="直播间封面")
     * @Apidoc\Param("placard", type="string",require=false,desc="直播间公告")
     * @Apidoc\Param("vedio_url", type="string",require=false,desc="视频地址")
     * @Apidoc\Returned(type="array",ref="app\api\model\LiveRoomModel\roomLiveSite")
     */
    public function startVedio()
    {
        $admin = $this->checkToken();
        if (!empty($admin['code'])) return $this->ReturnError($admin);

        $liveRoomModel = new apiLiveRoom();
        $room_info = $liveRoomModel->check($member_id);
        if (!empty($room_info['code'])) return $this->ReturnError($room_info);

        $end_time = date('Y-m-d H:i:s', time() + 24 * 3600);
        $streamName = Cache::store('redis')->get('streamRoom' . $room_info['room_id']) ?? $room_info['room_id'];
        $pull_domain = Config::get('tengxun_api.pull_url');
        $key = Config::get('tengxun_api.live_secretKey');
        $pull_info = $this->getPullUrl($pull_domain, $streamName, $key, $end_time);

        if (!empty($pull_info)) {
            $pull_info['rtmp_profile'] = $this->getTemplates();
            $pull_info['room_id'] = $room_info['room_id'];
            $result = $liveRoomModel->roomLiveSite($pull_info);
        }
        if (!empty($result['code'])) return $this->ReturnError($result);
        if (empty($result)) return $this->ReturnError(['code' => 5009, 'msg' => "数据错误"]);
        Cache::store('redis')->delete('liveRoom' . $member_id);
        Cache::store('redis')->delete('scoreLiveRoom');

        //记录主播开播时间
        Cache::store('redis')->ZADD('anchor_live', time(), $member_id);
        return $this->ReturnSuccess($result);
    }
```



#### **直播间历史消息导致的弹幕问题**

分开发

```php
public static function sendHistoryMessage($client_id, $room_id)
{
  // 获取 list 长度
  $length = Cache::store('redis')->lLen("liveChatHistory:" . $room_id);
  if ($length > 25) {
    $length = 25;
  }
  // 遍历 list
  $lists = Cache::store('redis')->lRange("liveChatHistory:" . $room_id, 0, $length);

  $data['content'] = [];
  $data['type'] = Enum::CHAT_SEND_MESSAGE;
  $data['member_type'] = "member";
  for ($i = count($lists) - 1; $i >= 0; $i--) {
    $arr = json_decode($lists[$i], true);
    $data['content'] = $arr;
    $data['nickname'] = $arr['nickname'] ?? '';
    $data['member_id'] = $arr['member_id'] ?? '';
    $data['room_id'] = $arr['room_id'] ?? '';
    $data['content']['userInfo']['level'] = $arr['level'] ?? '';
    $data['avatar'] = $arr['avatar'] ?? '';
    Gateway::sendToClient($client_id, json_encode($data));
  }
}
```





还是单独弄个推送来发历史消息吧

```
[{"playerId":3542,"nameEn":"Bradley Beal","nameChs":"\u5e03\u62c9\u5fb7\u00b7\u6bd4\u5c14","nameCht":"\u5df4\u7279\u5229\u6bd4\u723e","number":"3","positionCn":"\u540e\u536b","positionEn":"Guard"},{"playerId":5166,"nameEn":"Kyle Kuzma","nameChs":"\u5e93\u5179\u9a6c","nameCht":"\u53e4\u65af\u99ac","number":"33","positionCn":"\u524d\u950b","positionEn":"Forward"},{"playerId":5179,"nameEn":"Monte Morris","nameChs":"\u8499\u7279\u6469\u91cc\u58eb","nameCht":"\u8499\u7279-\u83ab\u91cc\u65af","number":"22","positionCn":"\u540e\u536b","positionEn":"Guard"},{"playerId":4351,"nameEn":"Kristaps Porzingis","nameChs":"K.\u6ce2\u5c14\u6d25\u5409\u65af","nameCht":"\u6ce2\u8f9b\u57fa\u65af","number":"6","positionCn":"\u524d\u950b","positionEn":"Forward"},{"playerId":6399,"nameEn":"Deni Avdija","nameChs":"\u5fb7\u5c3c-\u963f\u592b\u8fea\u4e9a","nameCht":"\u767b\u5c3c-\u4e9e\u592b\u8fea\u52a0","number":"9","positionCn":"\u524d\u950b","positionEn":"Forward"}]
```



```php
APP_DEBUG = true

[APP]
DEFAULT_TIMEZONE = Asia/Shanghai

[LANG]
default_lang = zh-cn
[JWT]
SECRET=77cbfde72aa5189814037c569b812086
refresh_ttl=864000

[DATABASE]
TYPE = mysql
HOSTNAME = 127.0.0.1
DATABASE = hainiu
USERNAME = root
PASSWORD = password
HOSTPORT = 3306
CHARSET = utf8
DEBUG = true

[DATABASE]
TYPE = mysql
HOSTNAME = 43.135.76.182
DATABASE = db_hainiu
USERNAME = u_hainiu
PASSWORD = hainiu@2022
HOSTPORT = 3306
CHARSET = utf8
DEBUG = true
  
```

```
//        $log['log_url'] = $_SERVER['REQUEST_SCHEME'].'://'.$_SERVER['HTTP_HOST'].$_SERVER['REQUEST_URI'];
        $log['log_url'] = 'https://'.$_SERVER['HTTP_HOST'].$_SERVER['REQUEST_URI'];
```







## Redis 集群

Redis 集群方案：

因为TP框架自带的Redis缓存不支持集群。 所以要自己封装类。

这样每个文件引用Redis的命名要改，类似这样：

由 use think\facade\Cache;

改为 use app\common\controller\Cache;

每个文件都有改动的话那所有功能都要测一遍

```php
<?php
declare (strict_types=1);

namespace app\common\controller;

use Predis\Client;
use RedisCluster;
use think\App;
use think\facade\Config;

class Cache
{
    /**
     * 静态成品变量 保存全局实例
     */
    private static $_instance = NULL;

    /**
     * 私有化默认构造方法，保证外界无法直接实例化
     */
    private function __construct()
    {
    }

    /**
     * 静态工厂方法，返还此类的唯一实例
     */
    public static function store($redis)
    {
        if (is_null(self::$_instance)) {
            $servers = Config::get('cluster');
            if ($redis == "redis") {
                // phpredis 扩展（C写的）
                self::$_instance = new RedisCluster(NUll, $servers);
                // predis 扩展 （PHP写的）
                // self::$_instance = new Client($servers, array('cluster' => $redis));
            } else {
                die('store method need param' . E_USER_ERROR);
            }
        }
        return self::$_instance;
    }

    /**
     * 防止用户克隆实例
     */
    public function __clone()
    {
        die('Clone is not allowed.' . E_USER_ERROR);
    }
}
```



```php
<?php

// +----------------------------------------------------------------------
// | redis cluster 配置
// +----------------------------------------------------------------------
return [
    // 本地配置
//    'tcp://127.0.0.1:7000',
//    'tcp://127.0.0.1:7002',
//    'tcp://127.0.0.1:7004',

    // 线上配置
    'tcp://172.19.0.14:6380',
    'tcp://172.19.0.12:6380',
    'tcp://172.19.0.6:6380',
];
```



```
RedisCluster.php
```

```php
<?php
/**
 * Created by PhpStorm.
 * User: snail
 * Date: 2017/8/3
 * Time: 下午3:10
 */

namespace think\cache\driver;

use think\cache\Driver;

class RedisCluster extends Driver
{
    /**
     * @var array
     */
    protected $options = [
        //主机或IP，如192.168.0.110,192.168.0.110
        'host'                => '127.0.0.1',//slave host
        //端口，如7001,7002,7003
        'port'                => 6379,
        //链接超时时间
        'timeout'             => 1.5,
        //读取超时时间
        'read_timeout'        => 1.5,
        //过期时间
        'expire'              => 0,
        //持久化链接
        'persistent'          => false,
        //缓存前缀
        'prefix'              => '',
        //是否需要json序列化
        'serialize'           => true,
        // 是否需要断线重连
        'break_reconnect'     => true,
        //最大重试连接次数
        'max_reconnect_times' => 20,
    ];

    /**
     * 架构函数
     *
     * @access public
     *
     * @param array $options 缓存参数
     *
     * @throws \Exception
     */
    public function __construct($options = [])
    {
        if (!extension_loaded('redis')) {
            throw new \BadFunctionCallException('not support: redis');
        }

        if (!empty($options)) {
            $this->options = array_merge($this->options, $options);
        }
        $this->init_connect();
    }

    /**
     * @param int $reconnect_times 重连次数
     *
     * @throws \Exception
     */
    protected function init_connect($reconnect_times = 0)
    {
        //此处进行分布式配置
        $params = array(
            'hosts' => explode(',', $this->options['host']),
            'ports' => explode(',', $this->options['port']),
        );
        //拼接参数
        $hostsNum = count($params['hosts']);
        $seeds = [];
        for ($i = 0; $i < $hostsNum; $i++) {
            $host = $params['hosts'][$i];
            $port = $params['ports'][$i] ? $params['ports'][$i] : $params['ports'][0];
            $seeds[$i] = $host . ":" . $port;
        }
        try {
            //连接并指定timeout和read_timeout
            $this->handler = new \RedisCluster(NULL, $seeds, $this->options["timeout"], $this->options["read_timeout"], $this->options["persistent"]);
            // 始终在主机和从机之间随机分配只读命令
            $this->handler->setOption(\RedisCluster::OPT_SLAVE_FAILOVER, \RedisCluster::FAILOVER_DISTRIBUTE);
        }
        catch (\Exception $e) {
            if ($this->isBreak($e)) {
                if ($reconnect_times <= $this->options['max_reconnect_times']) {
                    echo $reconnect_times . "<br/>";
                    sleep(0.5);
                    $this->init_connect(++$reconnect_times);
                } else {
                    throw $e;
                }
            } else {
                throw $e;
            }
        }
    }

    /**
     * 判断缓存
     * @access public
     * @param string $name 缓存变量名
     * @return bool
     */
    public function has($name): bool
    {
        return $this->handler->exists($this->getCacheKey($name)) ? true : false;
    }


    /**
     * 读取缓存
     * @access public
     * @param string $name    缓存变量名
     * @param mixed  $default 默认值
     * @return mixed
     */
    public function get($name, $default = null)
    {
        $this->readTimes++;
        $key   = $this->getCacheKey($name);
        $value = $this->handler->get($key);

        if (false === $value || is_null($value)) {
            return $default;
        }

        return $this->unserialize($value);
    }

    /**
     * 写入缓存
     * @access public
     * @param string            $name   缓存变量名
     * @param mixed             $value  存储数据
     * @param integer|\DateTime $expire 有效时间（秒）
     * @return bool
     */
    public function set($name, $value, $expire = null): bool
    {
        $this->writeTimes++;

        if (is_null($expire)) {
            $expire = $this->options['expire'];
        }

        $key    = $this->getCacheKey($name);
        $expire = $this->getExpireTime($expire);
        $value  = $this->serialize($value);

        if ($expire) {
            $this->handler->setex($key, $expire, $value);
        } else {
            $this->handler->set($key, $value);
        }

        return true;
    }

    /**
     * 自增缓存（针对数值缓存）
     * @access public
     * @param string $name 缓存变量名
     * @param int    $step 步长
     * @return false|int
     */
    public function inc(string $name, int $step = 1)
    {
        $this->writeTimes++;
        $key = $this->getCacheKey($name);

        return $this->handler->incrby($key, $step);
    }

    /**
     * 自减缓存（针对数值缓存）
     * @access public
     * @param string $name 缓存变量名
     * @param int    $step 步长
     * @return false|int
     */
    public function dec(string $name, int $step = 1)
    {
        $this->writeTimes++;
        $key = $this->getCacheKey($name);

        return $this->handler->decrby($key, $step);
    }

    /**
     * 删除缓存
     * @access public
     * @param string $name 缓存变量名
     * @return bool
     */
    public function delete($name): bool
    {
        $this->writeTimes++;

        $key    = $this->getCacheKey($name);
        $result = $this->handler->del($key);
        return $result > 0;
    }


    /**
     * 清除缓存
     * @access public
     * @return bool
     */
    public function clear(): bool
    {
        $this->writeTimes++;
        $this->handler->flushDB();
        return true;
    }

    public function clearTag(array $keys)
    {
        // 指定标签清除
        $this->handler->del($keys);
    }

    /**
     * 追加TagSet数据
     * @access public
     * @param string $name  缓存标识
     * @param mixed  $value 数据
     * @return void
     */
    public function append(string $name, $value): void
    {
        $key = $this->getCacheKey($name);
        $this->handler->sAdd($key, $value);
    }

    /**
     * 获取标签包含的缓存标识
     * @access public
     * @param string $tag 缓存标签
     * @return array
     */
    public function getTagItems(string $tag): array
    {
        $name = $this->getTagKey($tag);
        $key  = $this->getCacheKey($name);
        return $this->handler->sMembers($key);
    }

}
```





