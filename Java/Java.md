## Java

### Java入门

- 基础

	- 数据类型

		- 1. 基本数据类型

			- 

		-  1. 引用类型

			- 对象、数组都是引用数据类型。
			-  所有引用类型的默认值都是null。
			-  一个引用变量可以用来引用任何与之兼容的类型。
			-  例子：Site site = new Site("Runoob")。
			- 

		- 内存角度解释区别

			- 基本数据类型

				- 存在栈内存中，变量中存储的是真实的数据
				- 赋值给其它变量，也是赋的真实的值

			- 引用数据类型

				- 变量中存储的是地址值
				- 数据值是存储在其它空间(堆空间)，自己空间(栈空间中存储的是地址值

	- 其它运算符

		- 

			- &
			- ｜
			- <<
			- >>

- 数组

	- 介绍

		- 数组指的是一种容器，可以用来存储同种类型的多个值

	- 定义与初始化

		- 定义

			- 数据类型[] 数组名
int [] array
			- 数据类型 数组名[]
int array[]

		- 初始化

			- 含义

				- 在内存中，为数组容器开辟空间，并将数据存入容器中的过程。

			- 两种方式

				- 静态初始化

					- 手动指定数组元素，系统会根据元素个数，计算出数组的长度
					- 完整格式：数据类型[] 数组名 = new 数据类型[] {元素1，元素2，元素3...};

						- int[] arr = new int[] {11, 22, 33};

					- 简化格式：数据类型[] 数组名 = {元素1，元素2，元素3...};

						- int[] arr = {11, 22, 33}

				- 动态初始化

					- 初始化时指定数组长度，由系统为数组分配初始值。
					- 格式

						- 数据类型[] 数组名 = new 数据类型[数组长度];

					- 范例

						- int[] arr = new int[3];

				- 使用场景

					- 明确要操作的具体数据，用静态初始化

						- 

					- 明确元素个数，不明确具体数值，推荐使用动态初始化

						- 

		- 地址值

			- 如果直接打印数组变量结果是地址值
			- 扩展: 解释一下地址值的格式含义 [D@776ec8df

	- 元素访问

		- 利用索引对数组中的元素进行访问
		- 1. 获取数组里的元素

			- 格式：数组名[索引]

		- 2. 数据存储到数组

			- 格式：数组名[索引] = 具体数据/变量

	- 遍历

		- 将数组中所有的内容取出来，取出来之后可以（打印，求和，判断..）
		- 注意：遍历指的是取出数据的过程，不要局限的理解为，遍历就是打印！

	- 练习

		- 求最值

			- 

		- 交换数据

			- 
			- 

	- 内存图

		- 整个计算机的内存

			- 

		- 内存分配

			- 栈

				- 方法运行时使用的内存，比如main方法运行，进入方法栈中执行

					- 

			- 堆

				- 存储对象或数组，new来创建的，都存储在堆内存

			- 方法区

				- 存储可以运行的class文件

			- 本地方法栈

				- JVM在使用操作系统功能的时候使用，和我没开发无关

			- 寄存器

				- 给CPU使用，和我没开发无关

			- 注意：从JDK8开始，取消方法区，新增元空间。
把原来方法区的多种功能进行拆分，有的功能放到堆中，有的功能放到了元空间中。

		- 数组内存

			- 
			- 总结

				- 1. 只要是new出来的一定是在堆里面开辟了一个小空间
				- 2. 如果new了多次，那么在堆里面有多个小空间，每个小空间中都有各自的数据

		- 两个数组指向同一个空间的内存图

			- 
			- 结论

				- 1. 当两个数组指向同一个小空间时，其中一个数组对小空间中的值发生了改变，那么其它数组再次访问的时候都是修改之后的结果。

	- 二维数组

		- 

- 方法

	- 什么事方法？

		- 方法是程序中最小的执行单元

	- 实际开发中，什么时候用到方法？

		- 重复的代码、具有独立功能的代码可以抽取到方法中

	- 实际开发中，方法有什么好处？

		- 可以提高代码的复用性
		- 可以提高代码的可维护性

	- 格式

		- public static 返回值类型 方法名(参数) {
       方法体;
       return 返回值;
} 

	- 方法的内存

		- 方法调用的基本内存原理

			- 以图为例
			- 执行顺序为

				- 1. main 方法进栈，eat 方法进栈，study 方法进栈，打印 学习

					- 

				- 2. study方法出栈，eat方法打印 吃饭

					- 

				- 4. sleep 方法进栈，打印睡觉，

					- 

				- 5. sleep出栈，eat 方法出栈，main方法出栈

- 面向对象 OOP

	- Object-Oriented Programming.
	- 类和对象

		- 1. 类和对象是什么？

			- 类：是共同特征的描述(设计图); 对象：是真实存在的具体实例

		- 2. 如何得到对象？

			- 

		- 3. 拿到对象后能做什么？

			- 对象.成员变量;
			- 对象.成员方法(...)

		- 4. 几种类

			- Javabean类：用来描述一类事物的类。比如，Student、Teacher、Dog、Cat等
			- 测试类：用来检查其它类是否书写正确，带有main方法的类，是程序的入口
			- 工具类：帮助我们做一些事情，但是不描述任何事务的类

				- 类名见名知意
				- 私有化构造方法（不让外界创建测试类的对象，因为没有意义）
				- 方法定义为静态

	- static

		- static 表示静态，是Java中的一个修饰符，可以修饰成员方法，成员变量。

			- 被 static 修饰的成员方法，叫做静态方法

				- 多用在测试类和工具类中
				- Javabean 类中很少会用

			- 被 static 修饰的成员变量，叫做静态变量
			- 特点

				- 被该类所有对象共享。不属于对象，属于类
				- 随着类的加载而加载，优先于对象存在

			- 调用方式

				- 类名调用（推荐）
				- 对象名调用

		- 内存图

			- 静态在JDK8以前是存在方法区
			- 

		- 注意事项

			- 静态方法中，只能访问静态
			- 非静态方法可以访问所有
			- 静态方法中没有this关键字

		- 重新认识main方法

			- 
			- 

	- 三大特征

		- 封装 Encapsulation

			- 对象代表什么，就得封装对应的数据，并提供数据对应的行为

		- 继承 Inheritance

			- 
			- 特点

				- Java 只支持单继承，不支持多继承，但支持多层继承
				- Java 中所有的类都直接或间接继承于 Object 类

			- 成员变量

				- 内存图

					- 
					- 私有的能被继承下来，但不能被直接使用

				- 访问特点

					- 1. 就近原则，先在局部位置找，本类成员位置找，父类成员位置找，逐级向上
					- 2. 如果出现重名的成员变量怎么办？

						- 

			- 成员方法

				- 虚方法表

					- 
					- 作用：提高性能
					- 要求：非private、非static、非final 修饰的方法

				- 内存图

					- 

				- 访问特点

					- 就近原则
					- super 调用，直接访问父类

			- 子类能继承父类哪些内容

				- 

			- 方法的重写

				- 当父类的方法不能满足子类现在的需求时，需要进行方法的重写
				- 格式

					- 在继承体系中，子类出现了和父类中一摸一样的方法声明，我们就称子类这个方法是重写的方法

				- @Override 重写注解

					- 

				- 本质

					- 子类覆盖了从父类当中继承下来虚方法表里面的方法
					- 

				- 注意事项和要求

					- 

			- 构造方法

				- 访问特点

					- 父类中的构造方法不会被子类继承
					- 子类中所有的构造方法默认先访问父类中的无参构造，再执行自己
					- 为什么？

						- 子类在初始化的时候，有可能使用到父类中的数据，如果父类有完场初始化，子类将无法使用父类的数据。
						- 子类初始化之前，一定要调用父类构造方法先完成父类数据空间的初始化。

				- 怎么调用父类构造方法？

					- 子类构造方法的第一行语句默认都是：super()，不写也存在，且必须在第一行

		- 多态 Polymorphism

			- 什么是多态？

				- 同类型的对象，表现出单独不同形态。

			- 多态的表现形式

				- 父类类型 对象名称 = 子类对象;

			- 多态的前提

				- 有继承/实现关系
				- 有父类引用指向子类对象

					- Fu f = new Zi();

				- 有方法重写

			- 特点

				- 调用成员

					- 变量调用：编译看左边，运行也看左边。
					- 方法调用：编译看左边，运行看右边。

			- 内存图

				- 

			- 优势和劣势

				- 优势

					- 使用父类型作为参数，就可以接收所有子类对象，体现了多态的扩展性与便利。
					- 在多态形式下，右边对象可以实现解耦合，便于扩展和维护。

				- 弊端

					- 不能使用子类的特有功能
					- 解决办法

						- 强制类型转换

							- 可以转换称真正的子类类型，从而调用子类独有功能
							- 转换类型与真实对象类型不一致会报错 ⚠️ 
							- 转换时用 instanceof 关键字进行判断

			- 练习：

				- 
				- TestDemo

					- package com.moon.polymorphism1;

public class TestDemo {
    public static void main(String[] args) {
        Person wang = new Person(30, "老王");
        Animal animal = new Dog(2, "黑");
        wang.keepPet(animal, "骨头");

        Person li = new Person(25, "老李");
        Animal animal2 = new Cat(3, "灰");
        li.keepPet(animal2, "鱼");
    }
}


				- Person

					- package com.moon.polymorphism1;

public class Person {

    int age;
    String name;

    public Person() {
    }

    public Person(int age, String name) {
        this.age = age;
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void keepPet(Animal a, String something) {
        if (a instanceof Dog) {
            System.out.println("年龄为" + this.age + "的" + this.name + "养了一只" + a.color + "颜色的" + a.age + "岁的🐶");
            a.eat(something);
            Dog d = (Dog) a;
            d.lookHome();
        } else if (a instanceof Cat) {
            System.out.println("年龄为" + this.age + "的" + this.name + "养了一只" + a.color + "颜色的" + a.age + "岁的🐱");
            a.eat(something);
            Cat d = (Cat) a;
            d.catchMouse();
        }
    }

}

					- Animal

						- package com.moon.polymorphism1;

public class Animal {

    int age;
    String color;

    public Animal() {
    }

    public Animal(int age, String color) {
        this.age = age;
        this.color = color;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getColor() {
        return color;
    }

    public void setColor(String color) {
        this.color = color;
    }

    public void eat(String something) {
        System.out.println("动物在吃" + something);
    }
}


					- Cat

						- package com.moon.polymorphism1;

public class Cat extends Animal{

    public Cat() {
    }

    public Cat(int age, String color) {
        super(age, color);
    }

    @Override
    public void eat(String something) {
        System.out.println(getAge() + "岁的" + getColor() + "颜色的猫咪眯着眼睛侧着头吃" + something);
    }

    public void catchMouse() {
        System.out.println("cat catch mouse");
    }

}


					- Dog

						- package com.moon.polymorphism1;

public class Dog extends Animal {

    public Dog() {
    }

    public Dog(int age, String color) {
        super(age, color);
    }

    @Override
    public void eat(String something) {
        System.out.println(getAge() + "岁的" + getColor() + "颜色的狗两只前脚死死的抱住" + something + "猛吃");
    }

    public void lookHome() {
        System.out.println("dog look home");
    }
}


	- 包、final、权限修饰符、代码块

		- 包

			- 什么是包？

				- 

			- 规则

				- 

		- final

			- 修饰方法

				- 最终方法，不能被重写

			- 修饰类

				- 最终类，不能被继承

			- 修饰变量

				- 是常量，不能被修改

					- 基本数据类型：变量的值不能修改
					- 引用数据类型

						- 地址值不能修改，内部的属性值可以修改

		- 权限修饰符

			- 
			- 使用规则

				- 

		- 代码块

			- 分类

				- 局部

					- 提前结束变量的生命周期（已淘汰）

				- 构造

					- 抽取构造方法中的重复代码（不够灵活）

				- 静态

					- 数据的初始化（重点）

						- 为什么不能直接在方法中初始化呢？ 因为容易被反复调用，造成空间浪费！

	- 抽象类和抽象方法

		- 1. 作用(意义)

			- 抽取共性时，无法确定方法体，就把方法定义为抽象的。
			- 强制让子类按照某种格式重写。（规范代码）

		- 2. 格式

			- public abstract 返回值类型 方法名(参数列表);
			- public abstract class 类名{}

		- 3. 继承抽象类有那些要注意？

			- 要么重写抽象类中的所有抽象方法
			- 要么是抽象类

		- 抽象方法所在的类，必须是抽象类。

	- 接口

		- 接口和抽象类的异同

			- 

		- 接口和类之间的关系

			- 

		- 定义和使用

			- 

		- 成员的特点

			- 

		- JDK8 JDK9开始接口中新增的方法

			- 

				- 默认方法

					- 

				- 静态方法

					- 

				- 私有方法

					- 
					- 普通私有方法

						- 为默认方法服务

					- 静态私有方法

						- 为静态方法服务

		- 接口的应用

			- 

		- 适配器设计模式

			- 

	- 内部类

		- 什么是内部类？

			- 类的五大成员

				- 属性、方法、构造方法、代码块、内部类

			- 
			- 
			- 

		- 分类

			- 成员内部类
			- 静态内部类
			- 局部内部类
			- 匿名内部类

		- 成员内部类

			- 什么是成员内部类？

				- 写在成员位置的，属于外部类的成员。

					- 

			- 获取成员内部类对象

				- 方式一：

					- 在外部类中编写方法，对外提供内部类的对象

				- 方式二：

					- 直接创建格式：外部类名.内部类名 对象名 = 外部类对象.内部类对象;

			- 外部类成员变量和内部类成员变量重名时，在内部类如何访问？

				- System.out.println(Outer.this.变量名)

			- 内存图

				- 

		- 静态内部类

			- 1. 什么是静态内部类

				- 静态内部类是一种特殊的成员内部类

			- 2. 直接创建静态内部类对象的方式？

				- Outer.Inner oi = new Outer.Inner();

			- 3. 如何调用静态内部类中的方法？

				- 非静态方法：先创建对象，用对象调用
				- 静态方法：外部类名.内部类名.方法名();

		- 局部内部类

			- 1. 将内部类定义在方法里面叫做局部内部类，类似于方法里面的局部变量
			- 2. 外界是无法直接使用，需要在方法内部创建对象并使用。
			- 3. 该类可以直接访问外部类的成员，也可以访问方法内的局部变量

		- 匿名内部类

			- 1. 什么是匿名内部类？

				- 隐藏了名字的内部类，可以写在成员位置，也可以写在局部位置

			- 2. 匿名内部类的格式？

				- new 类名或接口名()  {
        重写方法;
};

			- 3. 格式的细节

				- 包含了继承或实现，方法重写，创建对象。
整体就是一个类的子类对象或者接口的实现类对象

			- 4. 使用场景

				- 当方法的参数是接口或类时，
以接口为例，可以传递这个接口的实现类对象，
如果实现类只要使用一次，就可以用匿名内部类简化代码

- 字符串

	- String

		- 概述

			- String 是Java定义好的一个类。定义在java.lang 包中，使用时不需要导包
			- Java 程序中的所有字符串（例如 “abcdefg"）。都被称为此类的对象
			- 字符串不可变，它们的值在创建后不能被更改

				- 产生了多少字符串

		- 创建

			- 1. 直接赋值

				- String name = "尼古拉斯蛋总";
				- Subtopic 2

			- 2. new

				- 
				- 字符数组和字节数组创建字符串对象

					- 

		- 内存分析

			- Java内存模型

				- 方法区作用

					- 代码运行时会编译程class字节码文件，然后加载到方法区当中，临时存储
					- 

				- StringTable(串池)

					- 只有直接赋值的字符串才存储在串池当中
					- 从JDK7后从方法区移到堆内存。

			- 直接赋值

				- 
				- 当使用双引号直接赋值时，系统会检查该字符串在串池中是否存在。

			- new

				- 每 new 一次就开辟新的空间
				- 
				- 缺点

					- 不会复用，相同字符串比较多会浪费内存空间

		- 常用方法

			- boolean equals(要比较的字符串)
			- boolean equalsIgnoreCase(要比较的字符串)
			- public char charAt(int index): 根据索引返回字符
			- public int length(): 返回此字符串的长度（数组的长度：数组名.length
			- String substring(int beginIndex, int endIndex) 截取

				- 注意点：包头不包尾，包左不包右

			- String substring(int beginIndex) 截取到末尾

	- StringBuilder

		- 概述

			- StringBuilder 可以看成一个容器，创建之后里面的内容是可变的

		- 作用

			- 提高字符串的操作效率
			- String 是不可变的，所以每次拼接字符串时会传创建新的字符串，浪费内存空间。

		- 构造方法

			- public StringBuilder()

				- 创建一个空白可变字符串对象，不含有任何内容

			- public StringBuilder(String str)

				- 根据字符串的内容，来创建可变字符串对象

					- 

		- 成员方法

			- public StringBuilder append (任意类型)

				- 添加数据，并返回对象本身

			- public StringBuilder reverse()

				- 反转容器中的内容

			- public int length()

				- 返回长度（字符出现的个数）

			- public String toString()

				- 通过 toString() 就可以实现把 StringBuilder 转换为 String

			- 演示

				- 链式编程：当我们在调用一个方法时，不需要用变量接收他的结果，可以继续调用其它方法
				- 为什么打印 StringBuilder 的变量结果不是地址值？

					- 因为 StringBuilder 是 Java 已经写好的类，Java 在底层对他做了一些特殊处理。打印的对象是属性值

		- 使用场景

			- 1. 字符串拼接
			- 2. 字符串反转

	- StringJoiner

		- 概述

			- StringJoiner 跟 StringBuilder 一样，也可以看成是一个容器，创建之后里面的内容是可变的。
			- JDK8 出现的

		- 作用

			- 提高字符串的操作效率，而且代码编写特别简洁，但是目前市场上很少有人用。

		- 构造方法

			- public StringJoiner (间隔符号)

				- 创建一个 StringJoiner 对象，指定拼接时的间隔符号

			- public StringJoiner（间隔符号，开始符号，结束符号)

				- 创建一个 StringJoiner 对象，指定拼接时的间隔符号、开始符号、结束符号

			- 

		- 成员方法

			- public StringJoiner add (添加的内容)

				- 添加数据，并返回对象本身

			- public int length()

				- 返回长度（字符出现的个数）

			- public String toString

				- 返回一个字符串（该字符串就是拼接之后的结果）

	- 字符串相关的底层原理

		- 1. 字符串存储的内存原理

			- 直接赋值会复用字符串常量池中的
			- new 出来的不会复用，而是开辟一个新的空间

		- 2. ==号比较的到底是什么？

			- 基本数据类型比较数据值
			- 引用数据类型比较地址值

		- 3. 字符串拼接的底层原理

			- 无变量

				- 拼接的时候没有变量参与，都是字符串相加。
触发字符串的优化机制。
在编译的时候就已经是最终结果了。
				- 编译之后就是拼接之后的结果，
				- 会复用串池中的字符串 

			- 有变量

				- JDK8以前

					- JDK8以前会使用StringBuilder拼接

						- 内存图。可以看到一个加号，堆内存中两个对象。很浪费。

				- JDK8

					- 优化：

						- 默认方案：预估字符串长度，并创建一个数组

					- 但是

						- 字符串拼接的时候有变量参数：
在内存中创建了很多对象，浪费空间。

				- 结论：如果很多字符串变量拼接，不要直接+。在底层会创建多个对象，浪费时间，浪费性能。

		- 4. StringBuilder 提高效率原理图

			- 
			- 面试题

				- 以下代码运行结果是？

					- 答案 FALSE
					- 解析

						- 字符串拼接的时候，如果有变量
						- JDK8以前：系统底层会自动创建一个StringBuilder 对象，然后再调用其 append 方法完场拼接。拼接后，再调用其 toString 方法转换为 String 类型，而 toString 方法的底层是直接 new 了一个字符串对象
						- JDK8版本：系统会预估字符串拼接之后的总大小，把要拼接的内容都放在数组中，此时也是产生一个新的字符串

				- 下列代码的运行结果是？

					- 答案 TRUE
					- 解析

						- 在编译的时候，就会将“a"+"b"+"c"拼接为 "abc"

		- 5. StringBuilder 源码分析

			- 默认创建一个长度为16的字节数组
			- 添加的内容长度小于16，直接存
			- 添加的内容大于16会扩容（原来的容量*2+2）
			- 如果扩容之后还不够，以实际长度为准
			- capacity() // 容量：最多装多少
			- length // 长度：已经装了多少

- 集合

	- 集合和数组对比

		- 数组

			- 长度固定
			- 可以存基本数据类型
			- 可以存引用数据类型

		- 集合

			- 长度可变
			- 不可以存基本数据类型（要转为包装类才可）
			- 可以存引用数据类型

	- 集合体系结构

		- 
		- 红色接口、蓝色实现类
		- List 系列集合：添加的元素是有序、可重复、有索引
		- Set 系列集合：添加的元素是无序、不重复、无索引

	- Collection

		- Collection 是单列集合的顶层(祖宗)接口，所有方法被List和Set系列共享
		- 基本方法

			- 
			- 
			- Collection的equals比较的是地址值，String类已经重写了equals方法，而我们自定义的类要自己重写equals方法
			- 

		- 遍历方式

			- 迭代器

				- 迭代器在Java中的类是Iterator，迭代器是集合专用的遍历方式

迭代器遍历不依赖索引
				- Collection 集合获取迭代器

					- 

				- Iterator 常用方法

					- 

				- 
				- 注意细节点

					- 1. 报错 NoSuchElementException

						- 

					- 2. 迭代器遍历完毕，指针不会复位

						- 

					- 3. 遍历中只能用一次next方法

						- 

					- 4. 迭代器遍历时，不能用集合的方法进行增加或者删除

						- 
						- 如果非要删除，就用迭代器提供的remove方法
如果要添加，暂时没有办法

			- 增强for遍历

				- 
				- 格式

					- 
					- 快速生成方式

						- 集合的名字 + for + 回车

				- 细节

					- 修改增强for中的变量，不会改变集合中原本的数据

			- Lambda表达式遍历

				- 

	- 单列集合

		- List

			- 特点

				- 有序：存和取的元素
				- 有索引：可以通过索引操作元素
				- 可重复：存储的元素可以重复

			- 特有方法

				- Collection 的方法List都继承了
				- List集合因为有索引，所以多了很多索引操作的方法。
				- 
				- 

			- 遍历

				- 迭代器
				- 列表迭代器

					- 

				- 增强for遍历
				- Lambda表达式
				- 普通for循环（因为List集合存在索引）
				- 5种遍历方式对比

					- 

		- ArrayList

			- 成员方法

				- 
				- 演示

		- LinkList

			- 
			- 用的很少了解下即可

	- 双列集合

		- 特点

			- 

		- Map

			- 双列集合的顶层接口，它的功能全部双列集合都可以继承使用
			- 常见API

				- get(K key)是通过key获取值
				- **put 方法细节**

					- 

				- 

			- 遍历方式

				- 1. 键找值

					- 
					- 

				- 2. 键值对
				- 3. Lambda

- 常用API

	- Math
	- Scanner

		- 用next、nextInt、nextDouble 弊端

			- 遇到空格、回撤、制表符的时候会停止

		- 键盘录入，不管什么类型统一使用nextLine，遇到回撤才停止
		- 

	- System

		- 系统相关方法

	- Runtime

		- 当前虚拟机的运行环境

	- Object

		- 是Java中的顶级父类。所有的类都直接或间接的继承于Object 类
		- 其中的方法可以被所有子类访问
		- toString()

			- 一般会重写，打印对象时打印属性

		- equals()

			- 比较对象时会重写，比较对象属性值是否相同

		- clone()

			- 默认浅克隆
			- 如果需要深克隆需要重写方法或者使用第三方工具类

	- Objects 

		- 是一个工具类，提供了一些方法去完成一些功能
		- 

	- 包装类

		- 
		- 什么是包装类

			- 基本数据类型所对应的对象。

				- 

			- JDK5以后对包装类新增了自动装箱、自动拆箱

		- 如何获取包装类对象

			- 不需要new，不需要调用方法，直接复制即可

				- 

		- Integer

			- 为什么结果是这样？

				- 
				- 底层原理：

					- 因为在实际开放中，-128~127之间的数据，用的比较多。

如果每次使用都是 new 对象，那么太浪费内存了

所以提前把这个范围之内的每个数据都创建好对象

如果要用到了不会创建新的，而是返回一句创建好的对象

			- 成员方法

				- 
				- 为什么返回值类型是String？

					- 因为有可能 int 或 long 类型装不下几十位的二进制

	- 练习

		- 1. 自己实现 parseInt 方法的效果，将字符串形式的数据转成正数。

			- 要求
字符串中只能是数字不能有其它字符
最少一位，最多10位
0不能开头
			- 

		- 2. 定义一个方法自己实现toBinaryString方法的效果，将一个十进制正数转成字符串表示的二进制

			- 思路

				- 除基取余法

					- 不断的除以基数（几进制，基数就是几）得到余数，直到商为0，再将余数倒着拼起来即可。
					- 

			- 实现

				- 

		- 3. 请使用代码实现计算你活了多少天，用JDK7和JDK8两种方式完成

			- 

		- 4. 判断一个年份是闰年还是平年，用JDK7和JDK8两种方式。
提示： 二月有29天是闰年，一年有366天是闰年

			- JDK8

				- 
				- 两种方法，用isLeapYear最简单

			- JDK7

				- 

- 常见算法

	- 查找

		- 七种查找方式

			- 

		- 数据没有任何顺序

			- 基本查找

				- 就是遍历数组

		- 数据一定要有顺序

			- 二分查找

				- 
				- 

			- 插值查找

				- 
				- 二分的改进
				- 前提：数组中数据分布比较均匀

			- 斐波那契查找

				- 
				- 二分的改进，了解就行

			- 二分、插值、斐波那契查询各自的特点

				- 

		- 数据无序中有序

			- 分块查找

				- 

			- 扩展的分块查找（无规律的数据）

				- 
				- 

			- 扩展分块查找（查找的过程中还需要添加数据）

				- 这个查找交哈希查找。这里了解下就行，后面会单独说。
				- 

	- 排序

		- 常见

			- 掌握：冒泡、选择、插入、快速 排序
			- 了解：希尔、堆、桶、归并、计数、基数 排序

		- 冒泡

			- 
			- 

		- 选择

			- 
			- 

		- 插入

			- 
			- 

		- 快速

			- 要用到递归算法

				- 什么是递归？

					- 方法中调用方法本身的现象

				- 作用

					- 把一个复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解。递归策略只需少量的程序就可描述出解题过程中所需要的多次重复计算

				- 核心

					- 找出口

						- 什么时候不再调用方法。

					- 找规律

						- 如何把大问题变成规模较小的问题

				- 练习

					- 1. 利用递归求1-100之间的和

						- 
						- 

					- 2.用递归求阶乘，阶乘：5! = 5 * 4 * 3 * 2 * 1

						- 
						- 内存图

							- 

			- 

				- 

		- 总结

			- 

	- API

		- Arrays

			- toString: 将数组变成字符串

				- Arrays.toString(arr)

			- binarySearch: 二分查找法查找元素

				- 

			- copyOf: 拷贝数组

				- 

			- copyOfRange: 拷贝数组（指定范围）

				- 

			- fill: 填充数组

				- 

			- sort: 排序

				- sort(数组）

					- 

				- sort(数组，排序规则）

					- 

				- 练习：按要求进行排序

					- 
					- 

	- 递归练习题

		- 不死神兔

			- 
			- 解法1

				- 

			- 解法2

				- 递归

		- 猴子吃桃子

			- 
			- 

		- 爬楼梯

			- 

- Lambda 表达式

	- 函数式编程

		- 

	- 标准格式

		- 

	- 总结

		- 

### 源码解读（底层原理）

- 迭代器

	- 

- LinkedList 添加元素

	- 

		- 

	- LinkedList<String> list = new LinkedList<>();

		- new的时候会有两个重要的节点，还有个size先不用管

			- 

	- 添加第一个元素 list.add("add")

		- 1. final Node<E> l = last; // last为null，因为才初始化
2.在堆内存new了一个newNode: 0x0011，头和尾节点都为null，中间为"aaa"
3. 如果last为null(也就是前面没有元素)，last和first都为0x0011

	- 添加第二个节点 bbb

		- 1. last为0x0011，0x0022头节点存的是0x0011
2. last 赋值为0x0022
3. l.next = newMode 意思为将0x0011的尾节点赋值为0x0022

	- 第三个元素同理

- ArrayList

	- 扩容机制

		- 1. 利用空参创建的集合，在底层创建一个默认长度为0的数组
		- 2. 添加第一个元素时，底层会创建一个新的长度为10的数组
		- 3. 存满时，会扩容1.5倍（新建长度为1.5倍的数组，将原数组拷贝到新数组）
		- 4. 如果一次添加多个元素，1.5倍还放不下，则新创建数组的长度以实际为准。

	- 不同JDK版本会略有不同，但核心代码一样，下面是JDK11版本
	- 
	- 

		- modCount++ 是记录操作数量
		- add("aaa", {}, 0); 调用了另一个add方法，
e是添加的元素，
elementData是当前的ArrayList所有元素，
size是长度

	- 如果size等于ArrayList的长度，就调用扩容方法grow()
	- 

### Netty入门

- Subtopic 1

