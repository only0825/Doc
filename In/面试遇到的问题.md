[TOC]

## 基础语法

### 值传递&引用传递

Java 中只有值传递

Java 中将实参传递给方法（或函数）的方式是 **值传递** ：

- 如果参数是基本类型的话，很简单，传递的就是基本类型的字面量值的拷贝，会创建副本。
- 如果参数是引用类型，传递的就是实参所引用的对象在堆中地址值的拷贝，同样也会创建副本。

### 重载和重写的区别

**重载**就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理

比如 `StringBuilder` 的构造方法)有相同的名字、不同的参数， 便产生了重载。

```
StringBuilder sb = new StringBuilder();
StringBuilder sb2 = new StringBuilder("HelloWorld");
```

**重写**发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。

1. 方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。
2. 如果父类方法访问修饰符为 `private/final/static` 则子类就不能重写该方法，但是被 `static` 修饰的方法能够被再次声明。
3. 构造方法无法被重写

综上：**重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。**

### 什么是可变长参数？

从 Java5 开始，Java 支持定义可变长参数，所谓可变长参数就是允许在调用方法时传入不定长度的参数。就比如下面的这个 `printVariable` 方法就可以接受 0 个或者多个参数。

```java
public static void method1(String... args) {
   //......
}
```

另外，可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数。

```java
public static void method2(String arg1, String... args) {
   //......
}
```

**遇到方法重载的情况怎么办呢？会优先匹配固定参数还是可变参数的方法呢？**

答案是会优先匹配固定参数的方法，因为固定参数的方法匹配度更高。

### 对static和final的理解

- final类**不能被继承，没有子类，final类中的方法默认是final的**。
- final**方法不能被子类的方法覆盖，但可以被继承**。
- final成员变量表示常量，**只能被赋值一次，赋值后值不再改变**。
- final不能用于修饰构造方法。

注意：父类的private成员方法是不能被子类方法覆盖的，因此private类型的方法默认是final类型的。

*  static表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法，Java语言中没有全局变量的概念
*  被**static修饰的成员变量和成员方法独立于该类的任何对象**

### == 和 equals() 的区别

**`==`** 对于基本类型和引用类型的作用效果是不同的：

- 对于基本数据类型来说，`==` 比较的是值。
- 对于引用数据类型来说，`==` 比较的是对象的内存地址。

> 因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。

**`equals()`** 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。`equals()`方法存在于`Object`类中，而`Object`类是所有类的直接或间接父类，因此所有的类都有`equals()`方法。

#### 为什么重写 equals() 时必须重写 hashCode() 方法？

- `equals` 方法判断两个对象是相等的，那这两个对象的 `hashCode` 值也要相等。
- 两个对象有相同的 `hashCode` 值，他们也不一定是相等的（哈希碰撞）。

### 自动装箱与拆箱了解吗？原理是什么？

**什么是自动拆装箱？**

- **装箱**：将基本类型用它们对应的引用类型包装起来；
- **拆箱**：将包装类型转换为基本数据类型；

举例：

```java
 Integer i = 10;  //装箱
int n = i;   //拆箱
```

### 说一下集合中有哪些类，说一下常用的，你知道的

**List集合**下最常见的集合类有两个：ArrayList和LinkedList
**Set集合**下最常见的集合类有三个：HashSet、TreeSet、LinkedHashSet
**Map集合**最常见的子类也有三个：HashMap、LinkedHashMap、TreeMap



### 泛型占位符T和R区别？(约定俗成)

1. E - Element (在集合中使用，因为集合中存放的是元素)；
2. T - Type（Java 类）；
3. K - Key（键）；
4. V - Value（值）；
5. N - Number（数值类型）；
6. R - Result （返回结果，多用于函数式编程）；
7. ? - 表示不确定的java类型。

### 类和对象在JVM中是如何存储的？

、无论是Java中的类，还是对象，在JVM中都是以对象的形式存在的

### 接口和抽象类有什么共同点和区别？

**共同点** ：

- 都不能被实例化。
- 都可以包含抽象方法。
- 都可以有默认实现的方法（Java 8 可以用 `default` 关键字在接口中定义默认方法）。

**区别** ：

- 接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系（比如说我们抽象了一个发送短信的抽象类，）。
- 一个类只能继承一个类，但是可以实现多个接口。
- 接口中的成员变量只能是 `public static final` 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。

### 深拷贝和浅拷贝区别了解吗？什么是引用拷贝？

关于深拷贝和浅拷贝区别，我这里先给结论：

- **浅拷贝**：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。
- **深拷贝** ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。

**那什么是引用拷贝呢？** 简单来说，引用拷贝就是两个不同的引用指向同一个对象。

### 说说Synchronized 锁

synchronized 同步

成员方法：`public synchronized void run(){ }`

静态方法：`public static synchronized void run(){ }`

语句块：`synchronized(obj){ }`

当两个并发线程(thread1和thread2)访问同一个对象(syncThread)中的synchronized代码块时，在同一时刻只能有一个线程得到执行，另一个线程受阻塞，必须等待当前线程执行完这个代码块以后，其他线程才能执行该代码块。Thread1和thread2是互斥的，因为在执行synchronized代码块时会锁定当前的对象，只有执行完该代码块才能释放该对象锁，其他线程才能执行并锁定该对象。 

### 用过什么设计模式，各个设计模式的使用场景？

#### 单例模式

- 保证一个类只有一个实例，并且提供一个访问该全局访问点
- 创建方式两种：**饿汉式**(类初始化时,会立即加载该对象，线程天生安全,调用效率高。)和**懒汉式**(类初始化时,不会初始化该对象,真正需要使用的时候才会创建该对象,具备懒加载功能。)

#### 工厂模式







### 秒杀系统的解决方案

## 消息队列



### 堆和栈区别 内存中他们分别存储的什么？

## 网络知识

#### TCP/IP 三次握手、四次挥手

三次握手：

* C：我要建立连接了 
* B：我同意与你建立连接
* C：我知道你同意建立连接了

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa3df9945203433f976a1137273ffc68~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

四次挥手：

* C：我没有消息了，可以断开连接
* S：我知道了你想断开了
* S：我也没什么消息了，可以断开
* C：我知道你断开了。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/85a68024ad2c4ff0996ff61eac602bff~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

## MySQL

#### MyISAM 和 InnoDB区别

* MyISAM 无事务 表锁  大量查询时使用

  ```
  适合于一些需要**大量查询**的应用，但其对于有大量写操作并不是很好。甚至你只是需要update一个字段，整个表都会被锁起来(**表锁**)，而别的进程，就算是读进程都无法操作直到读操作完成。另外，MyISAM 对于 SELECT COUNT(*) 这类的计算是超快无比的。**没有事务**
  ```

* InnoDB   事务 行锁  大量写操作时使用

* ```
  的趋势会是一个非常复杂的存储引擎，对于一些小的应用，它会比 MyISAM 还慢。但是它支持“**行锁**” ，于是在**写操作**比较多的时候，会更优秀。并且，他还支持更多的高级应用，比如：**有事务**。
  ```

#### MyISAM和InnoDB在数据库怎么存储的？

#### Mybatis中连接池存储的是什么

对象

#### 做过mysql优化吗？mysql优化常用到的几种方式，简单说一下？

用EXPLAIN 分析SQL语句是否合理的走了索引，没有就加上、还要看索引合不合适

用索引，做过的项目：将表的url加密成md5和len，给md5和len做索引

1. 选取最适用的字段属性
2. 使用连接（JOIN）来代替子查询(Sub-Queries)
3. 使用联合(UNION)来代替手动创建的临时表
4. 锁定表
5. 使用外键
6. 使用索引
7. 优化的查询语句

#### EXPLAIN 有哪些列，你看哪些列来优化SQL的？

https://segmentfault.com/a/1190000008131735

```sql
mysql> explain select * from user_info where id = 2\G
*************************** 1. row ***************************
           id: 1         # SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.
  select_type: SIMPLE    # SELECT 查询的类型.
        table: user_info # 查询的是哪个表
   partitions: NULL      # 匹配的分区
         type: const
possible_keys: PRIMARY   # 此次查询中可能选用的索引
          key: PRIMARY   # 此次查询中确切使用到的索引.
      key_len: 8
          ref: const     # 哪个字段或常数与 key 一起被使用
         rows: 1		 # 显示此查询一共扫描了多少行. 这个是一个估计值.
     filtered: 100.00    # 表示此查询条件所过滤的数据的百分比
        Extra: NULL		 # 额外的信息	
1 row in set, 1 warning (0.00 sec)
```

**select_type** 表示了查询的类型, 它的常用取值有:

- SIMPLE, 表示此查询不包含 UNION 查询或子查询
- PRIMARY, 表示此查询是最外层的查询
- UNION, 表示此查询是 UNION 的第二或随后的查询
- DEPENDENT UNION, UNION 中的第二个或后面的查询语句, 取决于外面的查询
- UNION RESULT, UNION 的结果
- SUBQUERY, 子查询中的第一个 SELECT
- DEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.

**type** 字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过 `type` 字段, 我们判断此次查询是 `全表扫描` 还是 `索引扫描` 等.

- `system`: 表中只有一条数据. 这个类型是特殊的 `const` 类型.

- `const`: 针对主键或唯一索引的等值查询扫描, 最多只返回一行数据. const 查询速度非常快, 因为它仅仅读取一次即可.

- `eq_ref`: 此类型通常出现在多表的 join 查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果. 并且查询的比较操作通常是 =, 查询效率较高. 例如:

#### 什么是索引

索引是帮助MySQL高效获取数据的排好序的数据结构。

如果不用索引 

#### 索引类型

普通、唯一、主键、组合

#### 索引数据结构

* 二叉树
* 红黑树（全称二叉平衡树，他能自我平衡）
* Hash表
* B-Tree
  1. 一个节点有多个元素
  2. 节点中的数据索引从左到右递增排列
* B+Tree （MySQL底层数据结构）
  1. 一个节点有多个元素 （Max.Degree设置）
  2. 节点中的数据索引从左到右递增排列
  3. 叶子节点间有指针
  4. 非叶子节点上面的元素都冗余了一份到叶子节点上面

#### MySQL为什么选择B+ Tree(B-Tree的优化)做索引呀？

二叉树 缺点：如果递增的数据就会是顺序存储，效率不高

红黑树 去点：比二叉树好点，但不够好。但一旦数据量打了，如五百万数据，就有500万索引，那么树的高度会非常高！

#### 怎么分析SQL？

1. ##### 执行计划 EXPLAIN

2. #### show profile 验证一下

#### 分页查询的SQL怎么优化？

select * from talbe limit 1000000, 10  这条怎么优化 (偏移量越大，查询时间越久)

* 可以用 select id from talbe limit 1000000, 10
* **最大id查询法**  select * from talbe where id > 1000000 limit 10 (这种比较局限，只能适用于自增组件，那个uuid生成的主键这种方式不适用)
* **BETWEEN … AND** (也只能适用于自增主键，并且id没有断裂)
* **子查询**  select * from talbe where id > (select id from user limit 1000000,1) limit 10
* **分表查询**: **水平分表** **垂直分表**  **冷热表**(比如最近一个月的表存一张表，一个月以前的数据存另一张表)

#### 如何分库分表

**垂直分片**：从业务角度将不同的表放到不同的库中。能解决数据分布问题，但不能解决查询效率低的问题

**水平分片**：从数据的角度将一个表中的数据拆分到不同的库或表中

**分片策略**：

1. 取余\取模：id%2 = 1  基数存一个片，去id%2=0  偶数存一个片   优点：分散非常平均  缺点：不好扩展
2. 时间范围，如一个月分一个片，好扩展，但数据不够平均
3. 热点数据分出来
4. 枚举值分片：例如按照地区分片
5. 按照目标字段前缀指定进行区分：自定义业务规则分片

一张表数据量500W 就要考虑分库分表了。



#### 怎么实现读写分离 ？

主从复制、读写分离一般是一起使用的。目的很简单，就是**为了提高数据库的并发性能**

#### 悲观锁和乐观锁

乐观锁和悲观锁是两种思想，用于解决并发场景下的数据竞争问题。

- **乐观锁**：乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。 **场景**：比较适合读取操作比较频繁的场景
- **悲观锁**：悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据。**场景**：比较适合写入操作比较频繁的场景



## Redis

#### 常见的缓存

 文件缓存、Memcached缓存、Redis缓存

#### Redis与Memcached缓存区别

* memcache还可用于缓存其他东西，例如图片、视频等等；
* Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，hash等数据结构的存储；
* 存储数据安全–memcache挂掉后，数据没了；redis可以定期保存到磁盘（持久化）；

##### 使用场景

1、如果有持久方面的需求或对数据类型和处理有要求的应该选择redis。

2、如果简单的key/value 存储应该选择memcached。

#### Redis都有哪些数据结构（存储类型）？

Redis 有5 种基础数据结构，它们分别是：**string**(字符串)、**list**(列表)、**hash(**字典)、**set**(集合) 和**zset**(有序集合)

zset也叫Sorted Set

#### 你用到的Redis的使用场景

fan目录关键词先是查表将关键词存入到Redis。当泛目录新生成页面时查询redis

#### **Redis实现分布式锁**

Redis为单进程单线程模式，采用队列模式将并发访问变成串行访问，且多客户端对Redis的连接并不存在竞争关系Redis中可以使用SETNX命令实现分布式锁。

将 key 的值设为 value ，当且仅当 key 不存在。若给定的 key 已经存在，则 SETNX 不做任何动作
![在这里插入图片描述](https://segmentfault.com/img/remote/1460000038748357)
解锁：使用 del key 命令就能释放锁

解决死锁：

- 通过Redis中expire()给锁设定最大持有时间，如果超过，则Redis来帮我们释放锁。
- 使用 setnx key “当前系统时间+锁持有的时间”和getset key “当前系统时间+锁持有的时间”组合的命令就可以实现。

#### Redis实现秒杀

1. 创建秒杀队列

   ```php
   /**
        * 创建秒杀列表
        */
       public function createList()
       {
           $count = 30;
           $redisKey = 'goods_list';
   
           for ($i = 1; $i <= $count; $i++) {
               // 测试用，防止数据错误
               if (Redis::llen($redisKey) >= $count) {
                   break;
               }
               Redis::rpush($redisKey, $i);
           }
       }
   ```

2. 接下来是关键的一步，使用的是 Redis 的 `lpop` 命令获取商品 ID，利用的是 Redis 的原子性。

   ```php
   /**
        * 秒杀
        */
       public function buy()
       {
           // 随机用户名，无意义，仅做标记
           $username = Hash::make(now());
   
           if ($goodsId = Redis::lpop('goods_list')) {
               // 购买成功
               Redis::hset('buy_success', $goodsId, $username);
           } else {
               // 购买失败
               Redis::incr('buy_fail');
           }
       }
   ```

   

#### Redsi的雪崩和穿透和击穿，你遇到过的场景和解决方案？

#### **雪崩**：

1. 在批量往**Redis**存数据的时候，把每个Key的失效时间都加个随机值就好了，这样可以保证数据不会在同一时间大面积失效

   ```sql
   setRedis（Key，value，time + Math.random() * 10000）；
   ```

2. 如果**Redis**是集群部署，将热点数据均匀分布在不同的**Redis**库中也能避免全部失效的问题

3. 或者设置热点数据永远不过期，有更新操作就更新缓存就好了

#### **缓存穿透**

缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，我们数据库的 id 都是1开始自增上去的，如发起为id值为 -1 的数据或 id 为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大，严重会击垮数据库。

1. **缓存穿透**我会在接口层增加校验，比如用户鉴权校验，参数做校验，不合法的参数直接代码Return，比如：id 做基础校验，id <=0的直接拦截等。
2. **Redis**还有一个高级用法**布隆过滤器（Bloom Filter）**这个也能很好的防止缓存穿透的发生，他的原理也很简单就是利用高效的数据结构和算法快速判断出你这个Key是否在数据库中存在，不存在你return就好了，存在你就去查了DB刷新KV再return。

#### **缓存击穿**

是指一个Key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个Key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个完好无损的桶上凿开了一个洞。

1. 设置热点数据永远不过期。或者加上互斥锁就能搞定了



## Spring相关

#### Spring Bean注入属性有哪几种方式呢？（Spring面试必问）

4种  setter注入  构造器注入   注解注入  java Config注入

#### 什么是事务

**事务是逻辑上的一组操作，要么都执行，要么都不执行。**

#### 事务的特性

- **原子性（Atomicity）：** 一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。
- **一致性（Consistency）：** 在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。
- **隔离性（Isolation）：** 数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括未提交读（Read uncommitted）、提交读（read committed）、可重复读（repeatable read）和串行化（Serializable）。
- **持久性（Durability）:** 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

#### Spring事务

##### 编程式事务管理

通过 `TransactionTemplate`或者`TransactionManager`手动管理事务，实际应用中很少使用，但是对于你理解 Spring 事务管理原理有帮助。

使用`TransactionTemplate` 进行编程式事务管理的示例代码如下：

##### 声明式事务管理

推荐使用（代码侵入性最小），实际是通过 AOP 实现（基于`@Transactional` 的全注解方式使用最多）。

使用 `@Transactional`注解进行事务管理的示例代码如下：







## 业务问题

#### 怎么优化注单查询的呢？
