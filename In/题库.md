

# JAVA基础语法

## 什么是基本数据类型和引用类型

### 基本数据类型

* 整数、浮点数、布尔、字符
* 存在栈内存中，变量中存储的是真实的数据
* 赋值给其它变量，也是赋的真实的值

### 引用数据类型

* 对象、数组都是引用数据类型。
* 变量中存储的是地址值
* 数据值是存储在其它空间(堆空间)，自己空间(栈空间中存储的是地址值

## 值传递&引用传递

Java 中只有值传递

Java 中将实参传递给方法（或函数）的方式是 **值传递** ：

- 如果参数是基本类型的话，很简单，传递的就是基本类型的字面量值的拷贝，会创建副本。
- 如果参数是引用类型，传递的就是实参所引用的对象在堆中地址值的拷贝，同样也会创建副本。

## String、StringBuffer、StringBuilder 的区别？



## 重载和重写的区别

**重载**就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理

比如 `StringBuilder` 的构造方法)有相同的名字、不同的参数， 便产生了重载。

```
StringBuilder sb = new StringBuilder();
StringBuilder sb2 = new StringBuilder("HelloWorld");
```

**重写**发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。

1. 方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。
2. 如果父类方法访问修饰符为 `private/final/static` 则子类就不能重写该方法，但是被 `static` 修饰的方法能够被再次声明。
3. 构造方法无法被重写

综上：**重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。**

## 什么是可变长参数？

从 Java5 开始，Java 支持定义可变长参数，所谓可变长参数就是允许在调用方法时传入不定长度的参数。就比如下面的这个 `printVariable` 方法就可以接受 0 个或者多个参数。

```java
public static void method1(String... args) {
   //......
}
```

另外，可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数。

```java
public static void method2(String arg1, String... args) {
   //......
}
```

**遇到方法重载的情况怎么办呢？会优先匹配固定参数还是可变参数的方法呢？**

答案是会优先匹配固定参数的方法，因为固定参数的方法匹配度更高。

## 对static和final的理解

- final类**不能被继承，没有子类，final类中的方法默认是final的**。
- final**方法不能被子类的方法覆盖，但可以被继承**。
- final成员变量表示常量，**只能被赋值一次，赋值后值不再改变**。
- final不能用于修饰构造方法。

注意：父类的private成员方法是不能被子类方法覆盖的，因此private类型的方法默认是final类型的。

*  static表示“全局”或者“静态”的意思，用来修饰成员变量和成员方法，Java语言中没有全局变量的概念
*  被**static修饰的成员变量和成员方法独立于该类的任何对象**





## == 和 equals() 的区别

**`==`** 对于基本类型和引用类型的作用效果是不同的：

- 对于基本数据类型来说，`==` 比较的是值。
- 对于引用数据类型来说，`==` 比较的是对象的内存地址。 

> 因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。

**`equals()`**比较字符串对象中的内容是否相等

equalsIgnoreCase 是忽略大小写的比较

#### 为什么重写 equals() 时必须重写 hashCode() 方法？

- `equals` 方法判断两个对象是相等的，那这两个对象的 `hashCode` 值也要相等。
- 两个对象有相同的 `hashCode` 值，他们也不一定是相等的（哈希碰撞）。

## 自动装箱与拆箱了解吗？原理是什么？

**什么是自动拆装箱？**

- **装箱**：将基本类型用它们对应的引用类型包装起来；
- **拆箱**：将包装类型转换为基本数据类型；

举例：

```java
 Integer i = 10;  //装箱
int n = i;   //拆箱
```

## 说一下集合中有哪些类，说一下常用的，你知道的

**List集合**下最常见的集合类有两个：ArrayList和LinkedList
**Set集合**下最常见的集合类有三个：HashSet、TreeSet、LinkedHashSet
**Map集合**最常见的子类也有三个：HashMap、LinkedHashMap、TreeMap



## 泛型占位符T和R区别？(约定俗成)

1. E - Element (在集合中使用，因为集合中存放的是元素)；
2. T - Type（Java 类）；
3. K - Key（键）；
4. V - Value（值）；
5. N - Number（数值类型）；
6. R - Result （返回结果，多用于函数式编程）；
7. ? - 表示不确定的java类型。

## 类和对象在JVM中是如何存储的？

、无论是Java中的类，还是对象，在JVM中都是以对象的形式存在的

## 接口和抽象类有什么共同点和区别？

**共同点** ：

- 都不能被实例化。
- 都可以包含抽象方法。
- 都可以有默认实现的方法（Java 8 可以用 `default` 关键字在接口中定义默认方法）。

**区别** ：

- 接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系（比如说我们抽象了一个发送短信的抽象类，）。
- 一个类只能继承一个类，但是可以实现多个接口。
- 接口中的成员变量只能是 `public static final` 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。

## 深拷贝和浅拷贝区别了解吗？什么是引用拷贝？

关于深拷贝和浅拷贝区别，我这里先给结论：

- **浅拷贝**：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。
- **深拷贝** ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。

**那什么是引用拷贝呢？** 简单来说，引用拷贝就是两个不同的引用指向同一个对象。

## 说说Synchronized 锁

synchronized 同步

成员方法：`public synchronized void run(){ }`

静态方法：`public static synchronized void run(){ }`

语句块：`synchronized(obj){ }`

当两个并发线程(thread1和thread2)访问同一个对象(syncThread)中的synchronized代码块时，在同一时刻只能有一个线程得到执行，另一个线程受阻塞，必须等待当前线程执行完这个代码块以后，其他线程才能执行该代码块。Thread1和thread2是互斥的，因为在执行synchronized代码块时会锁定当前的对象，只有执行完该代码块才能释放该对象锁，其他线程才能执行并锁定该对象。 

## 用过什么设计模式，各个设计模式的使用场景？

#### 单例模式

- 保证一个类只有一个实例，并且提供一个访问该全局访问点
- 创建方式两种：**饿汉式**(类初始化时,会立即加载该对象，线程天生安全,调用效率高。)和**懒汉式**(类初始化时,不会初始化该对象,真正需要使用的时候才会创建该对象,具备懒加载功能。)

#### 工厂模式



## 秒杀系统的解决方案

# 消息队列

## 堆和栈区别 内存中他们分别存储的什么？



# 网络知识

## TCP/IP 三次握手、四次挥手

三次握手：

* C：我要建立连接了 
* B：我同意与你建立连接
* C：我知道你同意建立连接了

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa3df9945203433f976a1137273ffc68~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

四次挥手：

* C：我没有消息了，可以断开连接
* S：我知道了你想断开了
* S：我也没什么消息了，可以断开
* C：我知道你断开了。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/85a68024ad2c4ff0996ff61eac602bff~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

# MySQL

## MyISAM 和 InnoDB区别

* MyISAM 无事务 表锁  大量查询时使用

  ```
  适合于一些需要**大量查询**的应用，但其对于有大量写操作并不是很好。甚至你只是需要update一个字段，整个表都会被锁起来(**表锁**)，而别的进程，就算是读进程都无法操作直到读操作完成。另外，MyISAM 对于 SELECT COUNT(*) 这类的计算是超快无比的。**没有事务**
  ```

* InnoDB   事务 行锁  大量写操作时使用

* ```
  的趋势会是一个非常复杂的存储引擎，对于一些小的应用，它会比 MyISAM 还慢。但是它支持“**行锁**” ，于是在**写操作**比较多的时候，会更优秀。并且，他还支持更多的高级应用，比如：**有事务**。
  ```

## MyISAM和InnoDB在数据库怎么存储的？

## Mybatis中连接池存储的是什么

对象

## 做过mysql优化吗？mysql优化常用到的几种方式，简单说一下？

用EXPLAIN 分析SQL语句是否合理的走了索引，没有就加上、还要看索引合不合适

用索引，做过的项目：将表的url加密成md5和len，给md5和len做索引

1. 选取最适用的字段属性
2. 使用连接（JOIN）来代替子查询(Sub-Queries)
3. 使用联合(UNION)来代替手动创建的临时表
4. 锁定表
5. 使用外键
6. 使用索引
7. 优化的查询语句

## EXPLAIN 有哪些列，你看哪些列来优化SQL的？

https://segmentfault.com/a/1190000008131735

```sql
mysql> explain select * from user_info where id = 2\G
*************************** 1. row ***************************
           id: 1         # SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.
  select_type: SIMPLE    # SELECT 查询的类型.
        table: user_info # 查询的是哪个表
   partitions: NULL      # 匹配的分区
         type: const
possible_keys: PRIMARY   # 此次查询中可能选用的索引
          key: PRIMARY   # 此次查询中确切使用到的索引.
      key_len: 8
          ref: const     # 哪个字段或常数与 key 一起被使用
         rows: 1		 # 显示此查询一共扫描了多少行. 这个是一个估计值.
     filtered: 100.00    # 表示此查询条件所过滤的数据的百分比
        Extra: NULL		 # 额外的信息	
1 row in set, 1 warning (0.00 sec)
```

**select_type** 表示了查询的类型, 它的常用取值有:

- SIMPLE, 表示此查询不包含 UNION 查询或子查询
- PRIMARY, 表示此查询是最外层的查询
- UNION, 表示此查询是 UNION 的第二或随后的查询
- DEPENDENT UNION, UNION 中的第二个或后面的查询语句, 取决于外面的查询
- UNION RESULT, UNION 的结果
- SUBQUERY, 子查询中的第一个 SELECT
- DEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.

**type** 字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过 `type` 字段, 我们判断此次查询是 `全表扫描` 还是 `索引扫描` 等.

- `system`: 表中只有一条数据. 这个类型是特殊的 `const` 类型.

- `const`: 针对主键或唯一索引的等值查询扫描, 最多只返回一行数据. const 查询速度非常快, 因为它仅仅读取一次即可.

- `eq_ref`: 此类型通常出现在多表的 join 查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果. 并且查询的比较操作通常是 =, 查询效率较高. 例如:

## 什么是索引

索引是帮助MySQL高效获取数据的排好序的数据结构。

如果不用索引 

## 索引类型

普通、唯一、主键、组合

## 索引数据结构

* 二叉树
* 红黑树（全称二叉平衡树，他能自我平衡）
* Hash表
* B-Tree
  1. 一个节点有多个元素
  2. 节点中的数据索引从左到右递增排列
* B+Tree （MySQL底层数据结构）
  1. 一个节点有多个元素 （Max.Degree设置）
  2. 节点中的数据索引从左到右递增排列
  3. 叶子节点间有指针
  4. 非叶子节点上面的元素都冗余了一份到叶子节点上面

## MySQL为什么选择B+ Tree(B-Tree的优化)做索引呀？

二叉树 缺点：如果递增的数据就会是顺序存储，效率不高

红黑树 去点：比二叉树好点，但不够好。但一旦数据量打了，如五百万数据，就有500万索引，那么树的高度会非常高！

## 怎么分析SQL？

1. ##### 执行计划 EXPLAIN

2. #### show profile 验证一下

## 分页查询的SQL怎么优化？

select * from talbe limit 1000000, 10  这条怎么优化 (偏移量越大，查询时间越久)

* 可以用 select id from talbe limit 1000000, 10
* **最大id查询法**  select * from talbe where id > 1000000 limit 10 (这种比较局限，只能适用于自增组件，那个uuid生成的主键这种方式不适用)
* **BETWEEN … AND** (也只能适用于自增主键，并且id没有断裂)
* **子查询**  select * from talbe where id > (select id from user limit 1000000,1) limit 10
* **分表查询**: **水平分表** **垂直分表**  **冷热表**(比如最近一个月的表存一张表，一个月以前的数据存另一张表)

## 如何分库分表

**垂直分片**：从业务角度将不同的表放到不同的库中。能解决数据分布问题，但不能解决查询效率低的问题

**水平分片**：从数据的角度将一个表中的数据拆分到不同的库或表中

**分片策略**：

1. 取余\取模：id%2 = 1  基数存一个片，去id%2=0  偶数存一个片   优点：分散非常平均  缺点：不好扩展
2. 时间范围，如一个月分一个片，好扩展，但数据不够平均
3. 热点数据分出来
4. 枚举值分片：例如按照地区分片
5. 按照目标字段前缀指定进行区分：自定义业务规则分片

一张表数据量500W 就要考虑分库分表了。

## 怎么实现读写分离 ？

主从复制、读写分离一般是一起使用的。目的很简单，就是**为了提高数据库的并发性能**

## 悲观锁和乐观锁

乐观锁和悲观锁是两种思想，用于解决并发场景下的数据竞争问题。

- **乐观锁**：乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。 **场景**：比较适合读取操作比较频繁的场景
- **悲观锁**：悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据。**场景**：比较适合写入操作比较频繁的场景



## Mysql事务

### MYSQL 事务处理主要有两种方法：

1、用 BEGIN, ROLLBACK, COMMIT来实现

- **BEGIN** 开始一个事务
- **ROLLBACK** 事务回滚
- **COMMIT** 事务确认

### **什么是ACID特性？**

- 原子性（atomicity)
  一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作。

- 一致性（consistency)
  数据库总是从一个一致性的状态转换到另外一个一致性的状态。在前面的例子中，一致性确保了，即使在执行第三、四条语句之间时系统崩溃，CMBC账户中也不会损失10万，不然要哭死，因为事务最终没有提交，所以事务中所做的修改也不会保存到数据库中。

- 隔离性（isolation)
  通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。在前面的例子中，当执行完第三条语句、第四条语句还未开始时，此时如果有其他人准备给你的CMBC账户存钱，那他看到的CMBC账户里还是有10万的。

- 持久性（durability)
  一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。持久性是个有点模糊的概念，因为实际上持久性也分很多不同的级别。有些持久性策略能够提供非常强的安全保障，而有些则未必。而且「不可能有能做到100%的持久性保证的策略」否则还需要备份做什么。

### **什么是脏读、不可重复读、幻读**

#### **脏读**

在事务A修改数据之后提交数据之前，这时另一个事务B来读取数据，如果不加控制，事务B读取到A修改过数据，之后A又对数据做了修改再提交，则B读到的数据是脏数据，此过程称为脏读Dirty Read。

| Time | 事务A                  | 事务B                          |
| ---- | ---------------------- | ------------------------------ |
| T1   | start transaction      | start transaction              |
| T2   | 查询CMBC账户余额10万   |                                |
| T3   | 工资入账10万，余额20万 |                                |
| T4   |                        | 查询到CMBC账户余额20万（脏读） |
| T5   | 取出10万，余额10万     |                                |
| T6   |                        | 买10万理财，余额修改为30万     |
| T7   |                        | commit                         |
| T8   | commit                 |                                |

#### **不可重复读**

一个事务内在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了变更、或者某些记录已经被删除了。

| Time | 事务A                          | 事务B                      |
| ---- | ------------------------------ | -------------------------- |
| T1   | start transaction              | start transaction          |
| T2   |                                |                            |
| T3   |                                | 查询CMBC账户余额10万       |
| T4   |                                | 买10万理财，余额修改为20万 |
| T5   |                                | commit                     |
| T6   | 查询CMBC余额20万（不可重复读） |                            |
| T7   |                                |                            |
| T8   | commit                         |                            |

#### **幻读**

事务A在按查询条件读取某个范围的记录时，事务B又在该范围内插入了新的满足条件的记录，当事务A再次按条件查询记录时，会产生新的满足条件的记录（幻行 Phantom Row）

| Time | 事务A                          | 事务B                   |
| ---- | ------------------------------ | ----------------------- |
| T1   | start transaction              | start transaction       |
| T2   | 查询CMBC账户，返回两条交易记录 |                         |
| T3   |                                | 买10万理财，交易记录加1 |
| T4   |                                |                         |
| T5   |                                | commit                  |
| T6   | 查询CMBC交易记录3条（幻读）    |                         |
| T7   |                                |                         |
| T8   | commit                         |                         |

#### 不可重复读与幻读有什么区别？

- 不可重复读的重点是修改：在同一事务中，同样的条件，第一次读的数据和第二次读的「数据不一样」。（因为中间有其他事务提交了修改）
- 幻读的重点在于新增或者删除：在同一事务中，同样的条件，第一次和第二次读出来的「记录数不一样」。（因为中间有其他事务提交了插入/删除）

# Redis

## 常见的缓存

 文件缓存、Memcached缓存、Redis缓存

## Redis与Memcached缓存区别

* memcache还可用于缓存其他东西，例如图片、视频等等；
* Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，hash等数据结构的存储；
* 存储数据安全–memcache挂掉后，数据没了；redis可以定期保存到磁盘（持久化）；

##### 使用场景

1、如果有持久方面的需求或对数据类型和处理有要求的应该选择redis。

2、如果简单的key/value 存储应该选择memcached。

## Redis都有哪些数据结构（存储类型）？

Redis 有5 种基础数据结构，它们分别是：**string**(字符串)、**list**(列表)、**hash(**字典)、**set**(集合) 和**zset**(有序集合)

zset也叫Sorted Set

## 你用到的Redis的使用场景

fan目录关键词先是查表将关键词存入到Redis。当泛目录新生成页面时查询redis



## 为什么需要分布式锁?

## 分布式锁怎么实现?

## 如何避免死锁?

mysql 发生死锁的原因以及如何解决

## **Redis实现分布式锁**

Redis为单进程单线程模式，采用队列模式将并发访问变成串行访问，且多客户端对Redis的连接并不存在竞争关系Redis中可以使用SETNX命令实现分布式锁。

将 key 的值设为 value ，当且仅当 key 不存在。若给定的 key 已经存在，则 SETNX 不做任何动作
![在这里插入图片描述](https://segmentfault.com/img/remote/1460000038748357)
解锁：使用 del key 命令就能释放锁

解决死锁：

- 通过Redis中expire()给锁设定最大持有时间，如果超过，则Redis来帮我们释放锁。
- 使用 setnx key “当前系统时间+锁持有的时间”和getset key “当前系统时间+锁持有的时间”组合的命令就可以实现。

## Redis实现秒杀

1. 创建秒杀队列

   ```php
   /**
        * 创建秒杀列表
        */
       public function createList()
       {
           $count = 30;
           $redisKey = 'goods_list';
   
           for ($i = 1; $i <= $count; $i++) {
               // 测试用，防止数据错误
               if (Redis::llen($redisKey) >= $count) {
                   break;
               }
               Redis::rpush($redisKey, $i);
           }
       }
   ```

2. 接下来是关键的一步，使用的是 Redis 的 `lpop` 命令获取商品 ID，利用的是 Redis 的原子性。

   ```php
   /**
        * 秒杀
        */
       public function buy()
       {
           // 随机用户名，无意义，仅做标记
           $username = Hash::make(now());
   
           if ($goodsId = Redis::lpop('goods_list')) {
               // 购买成功
               Redis::hset('buy_success', $goodsId, $username);
           } else {
               // 购买失败
               Redis::incr('buy_fail');
           }
       }
   ```

   

## Redis 到底是单线程还是多线程

* Redis 6.0 之前网络I/O 和 键值对 读写是由一个线程完成

* Redis 6.0 之后网络请求过程采用多线程，键值对读写命令依然是单线程处理，所以Redis 仍是并发安全的。
* 只有网络请求、数据操作模块是单线程，而其他的持久化、集群数据同步等，其实是由额外的线程执行的。

## Redis 单线程为什么还能这么快

1、命令执行基于内存操作，一条命了再内存里操作的时间是几十纳秒

2、命令执行是单线程操作，没有线程切换开销

3、基于 IO 多路复用机制提升 Redis 的I/O利用率

4、搞笑的数据存储结构：全局 hash 表以及多种高效数据结构，比如：跳表，压缩列表，链表等等

## Redis 主从、哨兵、集群架构优缺点比较

### 主从

* master 节点挂掉后，需要手动(写脚本)指定新的master，可用性不高，基本不用

### 哨兵

* 如果master节点异常，则会做主从切换，将某一台slave作为master。
* 哨兵配置略微复杂，并且性能和高可用性等方面表现一般，特别是在主从切换的瞬间存在访问瞬断的情况。
* 单个主节点内存不宜过大（不超过10G），否则否则会导致持久化文件过大，影响数据恢复或主从同步的效率

### 集群

* 由多个主从节点群组撑的分布式服务器群，具有复制、高可用和分片特性。
* 不需要sentine哨兵，也能完成节点移除和故障转移的功能。
* 需要将每个节点设置成集群模式，没有中心节点，可水平扩展。
* 官方文档说可线性扩展到上万个节点（推荐不超过1000个节点）。
* 性能和高可用性高于哨兵，且配置简单。

## 缓存雪崩、缓存穿透、缓存击穿

### 缓存雪崩

缓存雪崩是指缓存同一时间大面积失效，所以，后面的请求都会落到数据库熵，造成数据库短时间内成熟大量请求而崩掉。

**解决方案：**

* 缓存数据的过期时间`设置随机`，防止同一时间大量数据过期现象发生。
* 给每一个缓存数据增加相应的`缓存标记`，记录缓存是否失效，如果缓存标记失败，则更新数据缓存。
* `缓存预热`（写个接口 把热点数据放到存储中去，再启动redis）（故障导致数据都没了重启 或 第一次启动还没有数据 的**场景**）
* `互斥锁`（查一个缓存发现失效了，要去查库，查库的时候把缓存这个键锁起来，查完库后放入缓存再释放锁，可以防止大量请求对同一个键进行操作）

### 缓存穿透

缓存穿透是指缓存和数据库中都没有数据，导致所有的请求都落到数据库上，造成数据库短时间承受大量请求而崩掉。（一般是在攻击 或 商城等高并发场景才会出现缓存穿透）

**解决方案**：

* 接口层增加校验，如用户鉴权校验，id做基础校验，id<=0的直接拦截。
* 从缓存取不到且数据库也没有，这时也可将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击
* 采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力

### 缓存击穿

缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间过大，造成过大压力。和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据查不到从而查数据库

**解决方案**

* 设置热点数据用不过期
* 加互斥锁



# Spring相关

## Spring Bean注入属性有哪几种方式呢？（Spring面试必问）

4种  setter注入  构造器注入   注解注入  java Config注入

## 什么是事务

**事务是逻辑上的一组操作，要么都执行，要么都不执行。**

## 事务的特性

- **原子性（Atomicity）：** 一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。
- **一致性（Consistency）：** 在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。
- **隔离性（Isolation）：** 数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括未提交读（Read uncommitted）、提交读（read committed）、可重复读（repeatable read）和串行化（Serializable）。
- **持久性（Durability）:** 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

## Spring事务

### 编程式事务管理

通过 `TransactionTemplate`或者`TransactionManager`手动管理事务，实际应用中很少使用，但是对于你理解 Spring 事务管理原理有帮助。

使用`TransactionTemplate` 进行编程式事务管理的示例代码如下：

### 声明式事务管理

推荐使用（代码侵入性最小），实际是通过 AOP 实现（基于`@Transactional` 的全注解方式使用最多）。

使用 `@Transactional`注解进行事务管理的示例代码如下：





# 业务问题

## 怎么优化注单查询的呢？

## 设计一个抢红包系统

http://interview.xiaoyou66.com/pages/cfc81f/

## JWT使用流程

初次登陆：用户初次登陆，输入用户名密码

密码验证：服务器从数据库取出用户名和密码进行验证

生成JWT：服务器端验证通过，根据数据库返回的信息，以及预设规则，生成JWT

返还JWT：服务器的HTTP RESPONSE中将JWT返还

带JWT的请求：以后客户端发起请求，HTTP REQUEST

HEADER 中的 Authorization 字段要有值，为JWT

服务器验证JWT





